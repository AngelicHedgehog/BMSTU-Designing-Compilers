*$FROM Parser/Program/Program
$EXTERN Program;

/*
    <Parse t.Token*> == t.Errors t.TreeNode
    t.Errors ::= (ERR t.Error*)
    t.Error ::= s.Char*
    t.TreeNode ::= (s.Nterm (s.Token*) t.TreeNode*)
*/
$ENTRY Parse {
    e.Tokens
        , <Program () e.Tokens '$' (ERR)> : {
            t.ParseTree '$' t.Errors = t.ParseTree t.Errors;
            t.ParseTree t.Token e._ (e.Errors)
                = t.ParseTree (e.Errors (Token t.Token didnt recognized));
        };
}

/*
    <Rules (e.Scanned) t.Token* t.Errors> == t.TreeNode t.Token* t.Errors
*/
* Rules {
*     /* Rules ::= Rule Rules */
*     () (Rule e.R) e.Tokens t.Errs
*         = <Rules ((Rule e.R)) e.Tokens t.Errs>;
*     () ('<' e.OB) e.Tokens t.Errs
*         = <Rules () <Rule () ('<' e.OB) e.Tokens t.Errs>>;

*     ((Rule e.R)) (Rules e.Rs) e.Tokens t.Errs
*         = <Rules ((Rule e.R) (Rules e.Rs)) e.Tokens t.Errs>;
*     ((Rule e.R)) e.Tokens t.Errs
*         = <Rules ((Rule e.R)) <Rules () e.Tokens t.Errs>>;

*     (t.Rule (Rules e.Rs)) e.Tokens t.Errs
*         = (Rules (Rule Rules) t.Rule (Rules e.Rs)) e.Tokens t.Errs;

*     /* Rules ::= ε */
*     () e.Tokens t.Errs = (Rules ()) e.Tokens t.Errs;
* }

* Rule {
*     /* Rule ::= '<' Nterm '<' Altrule '>' Altrules '>' */
*     () ('<' e.OB) e.Tokens t.Errs = <Rule (('<' e.OB)) e.Tokens t.Errs>;

*     (('<' e.OB)) (Nterm e.N) e.Tokens t.Errs
*         = <Rule (('<' e.OB) (Nterm e.N)) e.Tokens t.Errs>;

*     (('<' e.OB1) t.Nterm) ('<' e.OB2) e.Tokens t.Errs
*         = <Rule (('<' e.OB1) t.Nterm ('<' e.OB2)) e.Tokens t.Errs>;

*     (e.Pref ('<' e.OB)) (Altrule e.A) e.Tokens t.Errs
*         = <Rule (e.Pref ('<' e.OB) (Altrule e.A)) e.Tokens t.Errs>;
*     (e.Pref ('<' e.OB)) e.Tokens t.Errs
*         = <Rule (e.Pref ('<' e.OB)) <Altrule () e.Tokens t.Errs>>;

*     (e.Pref (Altrule e.A)) ('>' e.CB) e.Tokens t.Errs
*         = <Rule (e.Pref (Altrule e.A) ('>' e.CB)) e.Tokens t.Errs>;

*     (e.Pref (Altrule e.A) ('>' e.CB)) (Altrules e.As) e.Tokens t.Errs
*         = <Rule (e.Pref (Altrule e.A) ('>' e.CB) (Altrules e.As)) e.Tokens t.Errs>;
*     (e.Pref (Altrule e.A) ('>' e.CB)) e.Tokens t.Errs
*         = <Rule (e.Pref (Altrule e.A) ('>' e.CB)) <Altrules () e.Tokens t.Errs>>;

*     (e.Pref (Altrules e.A)) ('>' e.CB) e.Tokens t.Errs
*         = <Rule (e.Pref (Altrules e.A) ('>' e.CB)) e.Tokens t.Errs>;

*     (e.Pref ('>' e.CB)) e.Tokens t.Errs
*         = (Rule ('<' Nterm '<' Altrule '>' Altrules '>')
*             e.Pref ('>' e.CB)) e.Tokens t.Errs;


*     (e.Scanned) '$' (ERR e.Errs)
*         = () '$' (ERR e.Errs (Unexpected EOF in Rule));
*     (e.Scanned) t.Token e.Tokens (ERR e.Errs)
*         = <Rule (e.Scanned) e.Tokens
*             (ERR e.Errs (Unexpected t.Token in Rule))>;
* }

* Altrules {
*     /* Altrules ::= '<' Altrule '>' Altrules */
*     () ('<' e.OB) e.Tokens t.Errs = <Altrules (('<' e.OB)) e.Tokens t.Errs>;

*     (('<' e.OB)) (Altrule e.A) e.Tokens t.Errs
*         = <Altrules (('<' e.OB) (Altrule e.A)) e.Tokens t.Errs>;
*     (('<' e.OB)) e.Tokens t.Errs
*         = <Altrules (('<' e.OB)) <Altrule () e.Tokens t.Errs>>;

*     (e.Pref (Altrule e.A)) ('>' e.CB) e.Tokens t.Errs
*         = <Altrules (e.Pref (Altrule e.A) ('>' e.CB)) e.Tokens t.Errs>;

*     (e.Pref ('>' e.CB)) (Altrules e.As) e.Tokens t.Errs
*         = <Altrules (e.Pref ('>' e.CB) (Altrules e.As)) e.Tokens t.Errs>;
*     (e.Pref ('>' e.CB)) e.Tokens t.Errs
*         = <Altrules (e.Pref ('>' e.CB)) <Altrules () e.Tokens t.Errs>>;

*     (e.Pref (Altrules e.As)) e.Tokens t.Errs
*         = (Altrules ('<' Altrule '>' Altrules) e.Pref (Altrules e.As)) e.Tokens t.Errs;

*     /* Rules ::= ε */
*     () e.Tokens t.Errs = (Altrules ()) e.Tokens t.Errs;


*     (e.Scanned) '$' (ERR e.Errs)
*         = () '$' (ERR e.Errs (Unexpected EOF in Altrules));
*     (e.Scanned) t.Token e.Tokens (ERR e.Errs)
*         = <Altrules (e.Scanned) e.Tokens
*             (ERR e.Errs (Unexpected t.Token in Altrules))>;
* }

* Altrule {
*     /* Altrule ::= Term Altrule */
*     () (Term e.T) e.Tokens t.Errs = <Altrule ((Term e.T)) e.Tokens t.Errs>;

*     ((Term e.T)) (Altrule e.A) e.Tokens t.Errs
*         = <Altrule ((Term e.T) (Altrule e.A)) e.Tokens t.Errs>;
*     ((Term e.T)) e.Tokens t.Errs
*         = <Altrule ((Term e.T)) <Altrule () e.Tokens t.Errs>>;

*     ((Term e.T) t.A) e.Tokens t.Errs
*         = (Altrule (Term Altrule) (Term e.T) t.A) e.Tokens t.Errs;

*     /* Altrule ::= Nterm Altrule */
*     () (Nterm e.N) e.Tokens t.Errs = <Altrule ((Nterm e.N)) e.Tokens t.Errs>;

*     ((Nterm e.N)) (Altrule e.A) e.Tokens t.Errs
*         = <Altrule ((Nterm e.N) (Altrule e.A)) e.Tokens t.Errs>;
*     ((Nterm e.N)) e.Tokens t.Errs
*         = <Altrule ((Nterm e.N)) <Altrule () e.Tokens t.Errs>>;

*     ((Nterm e.N) t.A) e.Tokens t.Errs
*         = (Altrule (Nterm Altrule) (Nterm e.N) t.A) e.Tokens t.Errs;

*     /* Altrule ::= ε */
*     () e.Tokens t.Errs = (Altrule ()) e.Tokens t.Errs;
* }
